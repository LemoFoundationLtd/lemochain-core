package types

import (
	"errors"
	"fmt"
	"github.com/LemoFoundationLtd/lemochain-go/common"
	"github.com/LemoFoundationLtd/lemochain-go/common/crypto/sha3"
	"github.com/LemoFoundationLtd/lemochain-go/common/log"
	"github.com/LemoFoundationLtd/lemochain-go/common/rlp"
	"io"
	"math/big"
	"reflect"
)

var (
	ErrUnknownChangeLogType  = errors.New("unknown change log type")
	ErrWrongChangeLogVersion = errors.New("the version of change log and account is not match")
	ErrAlreadyRedo           = errors.New("the change log's version is lower than account's. maybe it has redid")
	// ErrWrongChangeLogVersion is returned by the ChangeLog Undo/Redo if account has an unexpected version
	ErrWrongChangeLogData = errors.New("change log data is incorrect")
)

// ChangeLogProcessor is used to access account, and the intermediate data generated by transactions.
// It is implemented by account.Manager
type ChangeLogProcessor interface {
	GetAccount(addr common.Address) AccountAccessor
	PushEvent(event *Event)
	PopEvent() error
}

type ChangeLogType uint
type changeLogDecoder func(*rlp.Stream) (interface{}, error)
type changeLogDoFunc func(*ChangeLog, ChangeLogProcessor) error

type logConfig struct {
	TypeName      string
	NewValDecoder changeLogDecoder
	ExtraDecoder  changeLogDecoder
	Redo          changeLogDoFunc
	Undo          changeLogDoFunc
}

// logConfigs define how the log type map to action functions
var logConfigs = make(map[ChangeLogType]logConfig)

func RegisterChangeLog(logType ChangeLogType, TypeName string, newValDecoder, extraDecoder changeLogDecoder, redo, undo changeLogDoFunc) {
	logConfigs[logType] = logConfig{TypeName, newValDecoder, extraDecoder, redo, undo}
}

func (t ChangeLogType) String() string {
	config, ok := logConfigs[t]
	if ok {
		return config.TypeName
	}
	return fmt.Sprintf("ChangeLogType(%d)", t)
}

//go:generate gencodec -type ChangeLog -out gen_change_log_json.go

type ChangeLog struct {
	LogType ChangeLogType  `json:"type"       gencodec:"required"`
	Address common.Address `json:"address"    gencodec:"required"`
	// The No. of ChangeLog in an account
	Version uint32 `json:"version"    gencodec:"required"`

	// data pointer. Their content type depend on specific NewXXXLog function
	OldVal interface{} // It's used for undo. So no need to save or send to others
	NewVal interface{} `json:"newValue"   gencodec:"required"`
	Extra  interface{} `json:"extra"`
}

type rlpChangeLog struct {
	LogType ChangeLogType
	Address common.Address
	Version uint32
	NewVal  interface{}
	Extra   interface{}
}

// Hash returns the keccak256 hash of its RLP encoding.
func (c *ChangeLog) Hash() (h common.Hash) {
	hw := sha3.NewKeccak256()
	// this will call EncodeRLP
	rlp.Encode(hw, c)
	hw.Sum(h[:0])
	return h
}

// EncodeRLP implements rlp.Encoder.
func (c *ChangeLog) EncodeRLP(w io.Writer) error {
	return rlp.Encode(w, rlpChangeLog{
		LogType: c.LogType,
		Address: c.Address,
		Version: c.Version,
		NewVal:  c.NewVal,
		Extra:   c.Extra,
	})
}

// DecodeRLP implements rlp.Decoder.
func (c *ChangeLog) DecodeRLP(s *rlp.Stream) (err error) {
	if _, err = s.List(); err != nil {
		return err
	}
	if err = s.Decode(&c.LogType); err != nil {
		return err
	}
	if err = s.Decode(&c.Address); err != nil {
		return err
	}
	if err = s.Decode(&c.Version); err != nil {
		return err
	}

	// decode the interface{}
	config, ok := logConfigs[c.LogType]
	if !ok {
		log.Errorf("unexpected LogType %T", c.LogType)
		return ErrUnknownChangeLogType
	}
	if c.NewVal, err = config.NewValDecoder(s); err != nil {
		return err
	}
	if c.Extra, err = config.ExtraDecoder(s); err != nil {
		return err
	}
	// This error means there are some data need to be decoded
	err = s.ListEnd()
	return err
}

var bigIntType = reflect.TypeOf(big.Int{})

func formatIfIsBigInt(v interface{}) interface{} {
	result := v
	if reflect.TypeOf(result) == bigIntType {
		i := v.(big.Int)
		result = (&i).Text(10)
	}
	return result
}
func (c *ChangeLog) String() string {
	return fmt.Sprintf("%s: 0x%x %d %v %v %v", c.LogType, c.Address, c.Version, formatIfIsBigInt(c.OldVal), formatIfIsBigInt(c.NewVal), formatIfIsBigInt(c.Extra))
}

type ChangeLogSlice []*ChangeLog

func (c ChangeLogSlice) Len() int {
	return len(c)
}

func (c ChangeLogSlice) Less(i, j int) bool {
	return c[i].Version < c[j].Version
}

func (c ChangeLogSlice) Swap(i, j int) {
	c[i], c[j] = c[j], c[i]
}

func (c ChangeLogSlice) Search(version uint32) int {
	for i, value := range c {
		if value.Version == version {
			return i
		}
	}
	return -1
}

// FindByType find the first same type change log.
func (c ChangeLogSlice) FindByType(target *ChangeLog) *ChangeLog {
	for _, item := range c {
		if item.LogType == target.LogType {
			return item
		}
	}
	return nil
}

// Undo reverts the change. Its behavior depends on ChangeLog.ChangeLogType
func (c *ChangeLog) Undo(processor ChangeLogProcessor) error {
	config, ok := logConfigs[c.LogType]
	if !ok {
		log.Errorf("unexpected LogType %T", c.LogType)
		return ErrUnknownChangeLogType
	}

	accessor := processor.GetAccount(c.Address)
	currentVersion := accessor.GetVersion()
	// make sure the sequence of changelog is correct
	if currentVersion != c.Version {
		log.Errorf("expected undo version %d, got %d", c.Version, currentVersion)
		return ErrWrongChangeLogVersion
	}

	if err := config.Undo(c, processor); err != nil {
		return err
	}
	// increase version immediately so that next redo can check its version
	accessor.SetVersion(c.Version - 1)
	return nil
}

// Redo reply the change for light client. Its behavior depends on ChangeLog.ChangeLogType
func (c *ChangeLog) Redo(processor ChangeLogProcessor) error {
	config, ok := logConfigs[c.LogType]
	if !ok {
		log.Errorf("unexpected LogType %T", c.LogType)
		return ErrUnknownChangeLogType
	}

	accessor := processor.GetAccount(c.Address)
	currentVersion := accessor.GetVersion()
	// make sure the sequence of changelog is correct
	if c.Version < currentVersion+1 {
		log.Errorf("expected redo version %d, got %d", c.Version-1, currentVersion)
		return ErrAlreadyRedo
	} else if c.Version > currentVersion+1 {
		log.Errorf("expected redo version %d, got %d", c.Version-1, currentVersion)
		return ErrWrongChangeLogVersion
	}

	if err := config.Redo(c, processor); err != nil {
		return err
	}
	// increase version immediately so that next redo can check its version
	accessor.SetVersion(c.Version)
	return nil
}
